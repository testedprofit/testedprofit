<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GRIDLOCK: Gacha Defense</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&family=Share+Tech+Mono&display=swap');

        :root {
            --bg-dark: #0a0a12;
            --glass-bg: rgba(16, 20, 35, 0.9);
            --glass-border: rgba(255, 255, 255, 0.1);
            --neon-blue: #00f3ff;
            --neon-green: #05ffa1;
            --neon-red: #ff2a6d;
            
            --r-common: #a0a0a0;
            --r-rare: #0099ff;
            --r-epic: #bc13fe;
            --r-legendary: #ffaa00;
            --r-mythic: #ff0055;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; padding: 0;
            background-color: var(--bg-dark);
            color: #e0e6ed;
            font-family: 'Rajdhani', sans-serif;
            overflow: hidden;
            height: 100vh; width: 100vw;
            display: flex;
        }

        #bg-canvas { position: absolute; top: 0; left: 0; z-index: 0; opacity: 0.3; }

        #game-wrapper {
            position: relative; z-index: 10;
            display: flex; width: 100%; height: 100%;
        }

        #game-stage {
            flex-grow: 1; position: relative;
            overflow: hidden; cursor: crosshair;
            display: flex; align-items: center; justify-content: center;
        }

        canvas#game-canvas {
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            border: 1px solid var(--glass-border);
            background: rgba(0,0,0,0.2);
        }

        /* SIDEBAR */
        #sidebar {
            width: 340px;
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            border-left: 1px solid var(--glass-border);
            display: flex; flex-direction: column;
            padding: 0;
            z-index: 20;
            transition: 0.3s;
        }

        /* TABS */
        .tab-bar { display: flex; border-bottom: 1px solid var(--glass-border); }
        .tab-btn {
            flex: 1; padding: 15px;
            background: transparent; border: none;
            color: #666; font-family: 'Share Tech Mono';
            cursor: pointer; transition: 0.2s;
            border-bottom: 2px solid transparent;
        }
        .tab-btn.active { color: var(--neon-blue); border-bottom-color: var(--neon-blue); background: rgba(0, 243, 255, 0.05); }
        .tab-btn:hover { color: white; }

        .panel-content { padding: 20px; overflow-y: auto; flex-grow: 1; display: none; }
        .panel-content.active { display: flex; flex-direction: column; gap: 20px; }

        /* STATS */
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .stat-box {
            background: rgba(0,0,0,0.3); padding: 10px;
            border-radius: 4px; border: 1px solid rgba(255,255,255,0.05);
        }
        .stat-label { font-size: 0.7rem; color: #889; }
        .stat-value { font-size: 1.2rem; font-weight: 700; color: white; }
        .accent { color: var(--neon-green); }

        /* BUILD GRID */
        .build-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }

        .tower-btn {
            background: rgba(255,255,255,0.03);
            border: 1px solid var(--glass-border);
            border-radius: 4px; padding: 8px 4px;
            cursor: pointer; transition: all 0.2s;
            display: flex; flex-direction: column;
            align-items: center; gap: 4px;
            position: relative;
        }
        .tower-btn:hover { background: rgba(255,255,255,0.1); transform: translateY(-2px); }
        .tower-btn.selected { border-color: var(--neon-blue); background: rgba(0,243,255,0.1); }
        .tower-btn.disabled { opacity: 0.3; filter: grayscale(1); pointer-events: none; }

        .tower-icon { width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-size: 14px; }
        .tower-name { font-size: 0.7rem; font-weight: 600; text-align: center; line-height: 1; }
        .tower-cost { font-size: 0.65rem; color: #aaa; font-family: 'Share Tech Mono'; }
        
        .rarity-common { border-bottom: 2px solid var(--r-common); }
        .rarity-rare { border-bottom: 2px solid var(--r-rare); }
        .rarity-epic { border-bottom: 2px solid var(--r-epic); }
        .rarity-legendary { border-bottom: 2px solid var(--r-legendary); }
        .rarity-mythic { border-bottom: 2px solid var(--r-mythic); animation: rainbowBorder 2s infinite; }

        /* UPGRADE PANEL */
        #upgrade-panel {
            background: rgba(0,0,0,0.4);
            border: 1px solid var(--glass-border);
            padding: 15px;
            border-radius: 8px;
            display: none;
            flex-direction: column;
            gap: 10px;
        }
        #upgrade-panel.active { display: flex; }
        .upg-header { font-size: 1.1rem; color: var(--neon-blue); font-weight: bold; border-bottom: 1px solid #333; padding-bottom: 5px; }
        .upg-stat { display: flex; justify-content: space-between; font-size: 0.8rem; color: #ccc; }
        .btn-upgrade {
            background: var(--neon-green); color: black; border: none; padding: 10px;
            font-weight: bold; cursor: pointer; border-radius: 4px; font-family: 'Share Tech Mono';
        }
        .btn-upgrade:hover { background: #fff; }
        .btn-sell {
            background: transparent; color: var(--neon-red); border: 1px solid var(--neon-red); padding: 5px;
            cursor: pointer; border-radius: 4px; font-size: 0.8rem;
        }

        /* MARKET / GACHA */
        .crate-box {
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            border: 1px solid var(--neon-blue);
            padding: 20px; text-align: center;
            border-radius: 8px; position: relative; overflow: hidden;
            cursor: pointer; transition: 0.3s;
        }
        .crate-box:hover { box-shadow: 0 0 20px rgba(0, 243, 255, 0.3); transform: scale(1.02); }
        .crate-cost { font-size: 1.2rem; font-weight: bold; color: var(--neon-green); font-family: 'Share Tech Mono'; }
        .crate-anim {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: white; opacity: 0; pointer-events: none;
        }
        .drop-rates { font-size: 0.7rem; color: #888; margin-top: 10px; text-align: left; }
        .drop-row { display: flex; justify-content: space-between; margin-bottom: 2px; }

        #notification-area {
            position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
            z-index: 100; pointer-events: none;
            display: flex; flex-direction: column; gap: 5px; align-items: center;
        }
        .toast {
            background: rgba(0,0,0,0.9); border: 1px solid #333;
            padding: 10px 20px; border-radius: 4px;
            font-family: 'Share Tech Mono'; font-size: 0.9rem;
            animation: slideDown 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
            max-width: 300px; text-align: center;
        }
        .toast-title { font-weight: bold; font-size: 1.1rem; margin-bottom: 2px; }

        @keyframes rainbowBorder { 0%{border-color:red;} 20%{border-color:yellow;} 40%{border-color:lime;} 60%{border-color:cyan;} 80%{border-color:magenta;} 100%{border-color:red;} }
        @keyframes slideDown { from { transform: translateY(-20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes flash { 0%{opacity:0.8;} 100%{opacity:0;} }

        .screen-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 10, 0.9); backdrop-filter: blur(5px);
            z-index: 200; display: flex; justify-content: center; align-items: center;
        }
        .modal-box {
            background: rgba(16, 20, 35, 0.95); border: 1px solid var(--neon-blue);
            padding: 40px; width: 450px; text-align: center;
            box-shadow: 0 0 50px rgba(0, 243, 255, 0.15);
        }
        .btn-main {
            background: var(--neon-blue); color: #000; border: none;
            padding: 15px 40px; font-family: 'Rajdhani', sans-serif;
            font-size: 1.1rem; font-weight: 700; text-transform: uppercase;
            cursor: pointer; clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        }
        .btn-main:hover { background: white; box-shadow: 0 0 20px var(--neon-blue); }
        .hidden { display: none !important; }

        /* Timer Bar */
        #wave-timer-bar {
            width: 100%; height: 5px; background: #222; margin-bottom: 5px;
            display: none;
        }
        #wave-timer-fill {
            height: 100%; width: 100%; background: var(--neon-green);
            transition: width 0.1s linear;
        }

    </style>
</head>
<body>

<canvas id="bg-canvas"></canvas>
<div id="notification-area"></div>

<div id="game-wrapper">
    <div id="game-stage">
        <canvas id="game-canvas"></canvas>
    </div>

    <aside id="sidebar">
        <div class="tab-bar">
            <button class="tab-btn active" onclick="ui.switchTab('build')">SYSTEM</button>
            <button class="tab-btn" onclick="ui.switchTab('market')">MARKET</button>
        </div>

        <!-- BUILD TAB -->
        <div id="tab-build" class="panel-content active">
            <div class="stats-grid">
                <div class="stat-box"><div class="stat-label">INTEGRITY</div><div class="stat-value" style="color:var(--neon-red)" id="val-health">100%</div></div>
                <div class="stat-box"><div class="stat-label">WAVE</div><div class="stat-value" id="val-wave">1</div></div>
                <div class="stat-box" style="grid-column:span 2"><div class="stat-label">RAM (CURRENCY)</div><div class="stat-value accent" id="val-money">500</div></div>
            </div>

            <!-- UPGRADE PANEL (Dynamic) -->
            <div id="upgrade-panel">
                <div class="upg-header" id="upg-name">Tower Name</div>
                <div class="upg-stat"><span>Level</span> <span id="upg-lvl">1</span></div>
                <div class="upg-stat"><span>Damage</span> <span id="upg-dmg">10</span></div>
                <div class="upg-stat"><span>Range</span> <span id="upg-rng">3</span></div>
                <button class="btn-upgrade" id="btn-do-upgrade" onclick="game.upgradeSelected()">UPGRADE (150)</button>
                <button class="btn-sell" onclick="game.sellSelected()">RECYCLE UNIT</button>
            </div>

            <div style="font-size:0.8rem; color:#666; margin-top:10px; border-bottom:1px solid #333; padding-bottom:5px;">BLUEPRINTS</div>
            <div class="build-grid" id="tower-list">
                <!-- Injected via JS -->
            </div>
            
            <div style="margin-top: auto;">
                 <div id="wave-timer-bar"><div id="wave-timer-fill"></div></div>
                 <button id="btn-wave-ctrl" class="btn-main" style="width: 100%; font-size: 0.9rem;" onclick="game.waveControl()">INITIATE WAVE</button>
            </div>
        </div>

        <!-- MARKET TAB -->
        <div id="tab-market" class="panel-content">
            <div class="crate-box" onclick="game.openCrate()">
                <div id="crate-flash" class="crate-anim"></div>
                <h3>DATA CACHE</h3>
                <div class="crate-cost">500 RAM</div>
                <div style="font-size:0.8rem; margin-top:5px; color:#aaa;">Decrypt random blueprint</div>
            </div>

            <div class="drop-rates">
                <div style="margin-bottom:5px; font-weight:bold; color:white;">DROP RATES</div>
                <div class="drop-row"><span style="color:var(--r-common)">Common</span> <span>50%</span></div>
                <div class="drop-row"><span style="color:var(--r-rare)">Rare</span> <span>30%</span></div>
                <div class="drop-row"><span style="color:var(--r-epic)">Epic</span> <span>15%</span></div>
                <div class="drop-row"><span style="color:var(--r-legendary)">Legendary</span> <span>4%</span></div>
                <div class="drop-row"><span style="color:var(--r-mythic)">Mythic</span> <span>1%</span></div>
            </div>
        </div>
    </aside>
</div>

<div id="start-screen" class="screen-overlay">
    <div class="modal-box">
        <h1>GRID<span>LOCK</span></h1>
        <p>Defend the Mainframe.</p>
        <button class="btn-main" onclick="game.start()">BOOT SYSTEM</button>
    </div>
</div>

<div id="game-over-screen" class="screen-overlay hidden">
    <div class="modal-box">
        <h1 style="color: var(--neon-red);">CRASHED</h1>
        <p>System wiped.</p>
        <p>Waves: <span id="final-wave" style="color:var(--neon-blue)">0</span></p>
        <button class="btn-main" onclick="location.reload()">REBOOT</button>
    </div>
</div>

<script>
const AudioSys = {
    ctx: null,
    init: function() { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); },
    play: function(freq, type, dur, vol=0.1) {
        if(!this.ctx) return;
        const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
        o.type = type; o.frequency.value = freq;
        g.gain.setValueAtTime(vol, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
        o.connect(g); g.connect(this.ctx.destination);
        o.start(); o.stop(this.ctx.currentTime + dur);
    },
    sfx: {
        click: () => AudioSys.play(1200, 'sine', 0.05, 0.05),
        place: () => AudioSys.play(600, 'square', 0.1, 0.05),
        upgrade: () => AudioSys.play(1500, 'triangle', 0.2, 0.1),
        sell: () => AudioSys.play(400, 'sawtooth', 0.1, 0.1),
        error: () => AudioSys.play(150, 'sawtooth', 0.3, 0.1),
        gacha: () => {
            if(!AudioSys.ctx) return;
            const o = AudioSys.ctx.createOscillator(); const g = AudioSys.ctx.createGain();
            o.frequency.setValueAtTime(200, AudioSys.ctx.currentTime);
            o.frequency.linearRampToValueAtTime(800, AudioSys.ctx.currentTime + 0.5);
            g.gain.value = 0.1; o.connect(g); g.connect(AudioSys.ctx.destination);
            o.start(); o.stop(AudioSys.ctx.currentTime + 0.5);
        },
        shoot: (pitch=600) => AudioSys.play(pitch, 'triangle', 0.1, 0.03),
        boom: () => AudioSys.play(100, 'sawtooth', 0.3, 0.1),
        portal: () => AudioSys.play(300, 'sine', 0.3, 0.1)
    }
};

const RARITY = {
    COMMON: { color: '#a0a0a0', name: 'Common', prob: 0.5 },
    RARE: { color: '#0099ff', name: 'Rare', prob: 0.8 },
    EPIC: { color: '#bc13fe', name: 'Epic', prob: 0.95 },
    LEGENDARY: { color: '#ffaa00', name: 'Legendary', prob: 0.99 },
    MYTHIC: { color: '#ff0055', name: 'Mythic', prob: 1.0 }
};

const TOWERS = {
    'wall': { name: 'Block', cost: 20, range: 0, damage: 0, rate: 0, rarity: 'COMMON', type: 'wall', 
        draw: (ctx, s) => { 
            ctx.fillStyle = '#222'; ctx.fillRect(-s/2+2, -s/2+2, s-4, s-4);
            ctx.strokeStyle = '#555'; ctx.lineWidth = 2; ctx.strokeRect(-s/3, -s/3, s/1.5, s/1.5);
            ctx.beginPath(); ctx.moveTo(-s/2, -s/2); ctx.lineTo(s/2, s/2); ctx.moveTo(s/2, -s/2); ctx.lineTo(-s/2, s/2); ctx.stroke();
        } 
    },
    'rusty': { name: 'Rusty', cost: 50, range: 3, damage: 10, rate: 40, rarity: 'COMMON', type: 'turret', 
        draw: (ctx, s) => { 
            ctx.fillStyle = '#8b4513'; ctx.beginPath(); ctx.arc(0, 0, s/3, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#cd853f'; ctx.fillRect(0, -5, s/2, 10); // Barrel
            ctx.strokeStyle = '#a0522d'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, s/3, 0, Math.PI*2); ctx.stroke();
        }
    },
    'spike': { name: 'Spike', cost: 60, range: 1.5, damage: 50, rate: 40, rarity: 'COMMON', type: 'turret',
        draw: (ctx, s) => {
            ctx.fillStyle = '#444'; ctx.beginPath(); ctx.moveTo(0, -s/2); ctx.lineTo(s/3, s/3); ctx.lineTo(-s/3, s/3); ctx.fill();
            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.moveTo(0, -s/2); ctx.lineTo(s/6, 0); ctx.lineTo(-s/6, 0); ctx.fill();
        }
    },
    'ping': { name: 'Ping', cost: 75, range: 6, damage: 5, rate: 20, rarity: 'COMMON', type: 'turret',
        draw: (ctx, s) => {
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(0, s/2); ctx.lineTo(0, -s/2); ctx.stroke();
            ctx.beginPath(); ctx.arc(0, -s/2, 2, 0, Math.PI*2); ctx.fill();
        }
    },
    'basic': { name: 'Laser', cost: 100, range: 4, damage: 25, rate: 30, rarity: 'COMMON', type: 'turret',
        draw: (ctx, s) => { 
            ctx.fillStyle = '#00f3ff'; ctx.beginPath(); ctx.moveTo(s/2, 0); ctx.lineTo(-s/4, s/3); ctx.lineTo(-s/4, -s/3); ctx.fill();
            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, 0, s/6, 0, Math.PI*2); ctx.fill();
        }
    },
    'sniffer': { name: 'Sniffer', cost: 150, range: 3, damage: 5, rate: 20, rarity: 'RARE', type: 'turret', effect:'farm',
        draw: (ctx, s) => {
            ctx.strokeStyle = '#0099ff'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, s/3, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(s/4, s/4); ctx.lineTo(s/2, s/2); ctx.stroke(); // Handle
            ctx.fillStyle = 'rgba(0, 153, 255, 0.3)'; ctx.fill();
        }
    },
    'swarm': { name: 'Swarm', cost: 250, range: 4, damage: 8, rate: 40, rarity: 'RARE', type: 'turret', effect:'spread',
        draw: (ctx, s) => {
            ctx.fillStyle = '#00ff99'; 
            ctx.beginPath(); ctx.arc(-5, 5, 3, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(5, 5, 3, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(0, -5, 3, 0, Math.PI*2); ctx.fill();
        }
    },
    'gatling': { name: 'Gatling', cost: 400, range: 4, damage: 3, rate: 3, rarity: 'RARE', type: 'turret',
        draw: (ctx, s) => {
            ctx.fillStyle = '#555'; ctx.fillRect(-s/3, -s/3, s/1.5, s/1.5);
            ctx.fillStyle = '#ffff00'; 
            ctx.beginPath(); ctx.arc(0, -s/3, 3, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(s/3, 0, 3, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(-s/3, 0, 3, 0, Math.PI*2); ctx.fill();
        }
    },
    'miner': { name: 'Miner', cost: 300, range: 0, damage: 0, rate: 60, rarity: 'RARE', type: 'passive', effect:'income',
        draw: (ctx, s) => {
            ctx.fillStyle = '#ffd700'; ctx.fillRect(-s/3, -s/4, s/1.5, s/2);
            ctx.fillStyle = '#000'; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline='middle'; ctx.fillText('$', 0, 0);
        }
    },
    'frost': { name: 'Frost', cost: 200, range: 4, damage: 15, rate: 45, rarity: 'RARE', type: 'turret', effect:'slow',
        draw: (ctx, s) => {
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; 
            for(let i=0; i<3; i++) { ctx.save(); ctx.rotate(i*Math.PI/3); ctx.beginPath(); ctx.moveTo(-s/2, 0); ctx.lineTo(s/2, 0); ctx.stroke(); ctx.restore(); }
            ctx.fillStyle='#00f'; ctx.beginPath(); ctx.arc(0,0,5,0,Math.PI*2); ctx.fill();
        }
    },
    'launcher': { name: 'Launcher', cost: 500, range: 7, damage: 30, rate: 80, rarity: 'EPIC', type: 'turret', effect:'splash',
        draw: (ctx, s) => {
            ctx.fillStyle = '#333'; ctx.fillRect(-s/4, -s/2, s/2, s);
            ctx.fillStyle = '#f00'; ctx.beginPath(); ctx.moveTo(0, -s/2); ctx.lineTo(s/4, -s/4); ctx.lineTo(-s/4, -s/4); ctx.fill();
        }
    },
    'sniper': { name: 'Admin', cost: 350, range: 8, damage: 150, rate: 90, rarity: 'EPIC', type: 'turret',
        draw: (ctx, s) => {
            ctx.fillStyle = '#bc13fe'; ctx.fillRect(-s/2, -3, s, 6); // Barrel
            ctx.fillStyle = '#444'; ctx.fillRect(-s/4, -s/4, s/2, s/2); // Body
            ctx.strokeStyle = '#f0f'; ctx.beginPath(); ctx.arc(0, 0, s/2, 0, Math.PI*2); ctx.stroke(); // Scope ring
        }
    },
    'beam': { name: 'Beam', cost: 400, range: 5, damage: 10, rate: 5, rarity: 'EPIC', type: 'turret', effect:'pierce',
        draw: (ctx, s) => {
            ctx.strokeStyle = '#f0f'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(0, s/3); ctx.lineTo(0, -s/2); ctx.stroke();
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(0, s/3); ctx.lineTo(0, -s/2); ctx.stroke();
        }
    },
    'tesla': { name: 'Tesla', cost: 450, range: 5, damage: 40, rate: 40, rarity: 'EPIC', type: 'turret', effect:'chain',
        draw: (ctx, s) => {
            ctx.strokeStyle = '#0ff'; ctx.lineWidth = 2; 
            ctx.beginPath(); ctx.moveTo(0, s/3); 
            ctx.lineTo(-5, 0); ctx.lineTo(5, -s/4); ctx.lineTo(0, -s/2); ctx.stroke();
            ctx.fillStyle = '#0ff'; ctx.beginPath(); ctx.arc(0, s/3, 5, 0, Math.PI*2); ctx.fill();
        }
    },
    'firewall': { name: 'Burner', cost: 400, range: 3, damage: 5, rate: 5, rarity: 'EPIC', type: 'turret', effect:'burn',
        draw: (ctx, s) => {
            ctx.fillStyle = '#ff4500'; 
            ctx.beginPath(); ctx.arc(0, s/4, s/3, 0, Math.PI, false); 
            ctx.lineTo(0, -s/2); ctx.fill(); // Tear drop flame
        }
    },
    'buffer': { name: 'Buffer', cost: 500, range: 2.5, damage: 0, rate: 0, rarity: 'RARE', type: 'passive', effect:'buff',
        draw: (ctx, s) => {
            ctx.fillStyle = '#0f0'; ctx.fillRect(-s/3, -s/3, s/1.5, s/1.5);
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, s/4); ctx.lineTo(0, -s/4); ctx.lineTo(-5, -5); ctx.moveTo(0, -s/4); ctx.lineTo(5, -5); ctx.stroke();
        }
    },
    'portal': { name: 'Portal', cost: 1000, range: 5, damage: 5, rate: 100, rarity: 'LEGENDARY', type: 'turret', effect:'teleport',
        draw: (ctx, s) => {
            ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.arc(0,0, s/3, 0, Math.PI*2); ctx.stroke();
            ctx.fillStyle = '#000'; ctx.fill();
            ctx.fillStyle = '#0ff'; ctx.beginPath(); ctx.arc(0,0, s/6, 0, Math.PI*2); ctx.fill();
        }
    },
    'banhammer': { name: 'BAN', cost: 800, range: 10, damage: 1000, rate: 150, rarity: 'LEGENDARY', type: 'turret',
        draw: (ctx, s) => {
            ctx.fillStyle = '#888'; ctx.fillRect(-s/2, -2, s, 4); // Handle
            ctx.fillStyle = '#f00'; ctx.fillRect(s/4, -s/3, s/4, s/1.5); // Head
        }
    },
    'emp': { name: 'EMP', cost: 900, range: 4, damage: 50, rate: 80, rarity: 'LEGENDARY', type: 'turret', effect:'stun',
        draw: (ctx, s) => {
            ctx.strokeStyle = '#ff0'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(0, 0, s/4, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(-s/2, 0); ctx.lineTo(s/2, 0); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, -s/2); ctx.lineTo(0, s/2); ctx.stroke();
        }
    },
    'cloud': { name: 'Cloud', cost: 600, range: 6, damage: 50, rate: 10, rarity: 'LEGENDARY', type: 'turret', effect:'aoe',
        draw: (ctx, s) => {
            ctx.fillStyle = '#fff'; 
            ctx.beginPath(); ctx.arc(-10, 0, 10, 0, Math.PI*2); ctx.arc(10, 0, 10, 0, Math.PI*2); ctx.arc(0, -10, 12, 0, Math.PI*2); ctx.fill();
        }
    },
    'vortex': { name: 'Vortex', cost: 700, range: 4, damage: 5, rate: 5, rarity: 'LEGENDARY', type: 'turret', effect:'suck',
        draw: (ctx, s) => {
            ctx.strokeStyle = '#9400d3'; ctx.lineWidth = 2;
            ctx.beginPath(); 
            for(let i=0; i<3; i++) { ctx.arc(0, 0, (i+1)*5, i, i+Math.PI); }
            ctx.stroke();
        }
    },
    '404': { name: '404', cost: 1200, range: 5, damage: 0, rate: 60, rarity: 'MYTHIC', type: 'turret', effect:'delete',
        draw: (ctx, s) => {
            ctx.fillStyle = '#000'; ctx.fillRect(-s/2, -s/2, s, s);
            ctx.fillStyle = '#f00'; ctx.font = '10px monospace'; ctx.textAlign='center'; ctx.fillText('404', 0, 4);
        }
    },
    'orbital': { name: 'Orbital', cost: 3000, range: 20, damage: 500, rate: 60, rarity: 'MYTHIC', type: 'turret', effect:'global',
        draw: (ctx, s) => {
            ctx.strokeStyle = '#ff2a6d'; ctx.lineWidth=1;
            ctx.beginPath(); ctx.moveTo(0,-s/2); ctx.lineTo(0, s/2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(-s/2,0); ctx.lineTo(s/2, 0); ctx.stroke();
            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0,0,2,0,Math.PI*2); ctx.fill();
        }
    },
    'rng': { name: 'RNG', cost: 1500, range: 6, damage: 1, rate: 10, rarity: 'MYTHIC', type: 'turret', effect:'chaos',
        draw: (ctx, s) => {
            ctx.fillStyle = '#fff'; ctx.font='20px serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('?', 0, 0);
        }
    },
    'nuke': { name: 'Nuke', cost: 2000, range: 8, damage: 5000, rate: 300, rarity: 'MYTHIC', type: 'turret', effect:'nuke',
        draw: (ctx, s) => {
            ctx.fillStyle = '#ff0'; ctx.beginPath(); ctx.arc(0,0,s/2,0,Math.PI*2); ctx.fill();
            ctx.fillStyle = '#000'; 
            for(let i=0; i<3; i++) { ctx.save(); ctx.rotate(i*2*Math.PI/3); ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0,s/2, 0, Math.PI/3); ctx.fill(); ctx.restore(); }
        }
    },
    'doge': { name: 'Doge', cost: 1000, range: 6, damage: 200, rate: 20, rarity: 'MYTHIC', type: 'turret', effect:'meme',
        draw: (ctx, s) => {
            ctx.fillStyle = '#e5c07b'; ctx.beginPath(); ctx.arc(0,0,s/2.5,0,Math.PI*2); ctx.fill(); // Head
            ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(-5,-2,2,0,Math.PI*2); ctx.arc(5,-2,2,0,Math.PI*2); ctx.fill(); // Eyes
            ctx.beginPath(); ctx.moveTo(-3,5); ctx.lineTo(3,5); ctx.lineTo(0,8); ctx.fill(); // Nose
        }
    }
};

class Pathfinder {
    constructor(cols, rows) { this.cols = cols; this.rows = rows; }
    findPath(grid, start, end) {
        let queue = [start];
        let cameFrom = new Map();
        cameFrom.set(`${start.x},${start.y}`, null);
        let found = false;
        while(queue.length > 0) {
            let cur = queue.shift();
            if(cur.x === end.x && cur.y === end.y) { found = true; break; }
            [[0,-1],[1,0],[0,1],[-1,0]].forEach(([dx, dy]) => {
                let nx = cur.x + dx, ny = cur.y + dy;
                if(nx >= 0 && nx < this.cols && ny >= 0 && ny < this.rows && grid[nx][ny] === 0) {
                    let key = `${nx},${ny}`;
                    if(!cameFrom.has(key)) { cameFrom.set(key, cur); queue.push({x:nx, y:ny}); }
                }
            });
        }
        if(!found) return null;
        let path = [], curr = end;
        while(curr) { path.push(curr); curr = cameFrom.get(`${curr.x},${curr.y}`); }
        return path.reverse();
    }
}

const ui = {
    switchTab: (tab) => {
        AudioSys.sfx.click();
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.panel-content').forEach(p => p.classList.remove('active'));
        document.querySelector(`.tab-btn[onclick*='${tab}']`).classList.add('active');
        document.getElementById(`tab-${tab}`).classList.add('active');
    },
    renderInventory: () => {
        const list = document.getElementById('tower-list');
        list.innerHTML = '';
        game.inventory.forEach(id => ui.createBtn(list, id));
    },
    createBtn: (parent, id) => {
        const t = TOWERS[id];
        const el = document.createElement('div');
        el.className = `tower-btn rarity-${t.rarity.toLowerCase()}`;
        el.id = `btn-${id}`;
        el.onclick = () => game.selectTower(id);
        
        const iconCanvas = document.createElement('canvas');
        iconCanvas.width = 24; iconCanvas.height = 24;
        const ctx = iconCanvas.getContext('2d');
        ctx.translate(12, 12);
        t.draw(ctx, 20); 
        
        el.innerHTML = `<span class="tower-name">${t.name}</span><span class="tower-cost">${t.cost}</span>`;
        el.insertBefore(iconCanvas, el.firstChild);
        parent.appendChild(el);
    },
    toast: (title, msg, color='#fff') => {
        const el = document.createElement('div');
        el.className = 'toast';
        el.style.borderLeft = `4px solid ${color}`;
        el.innerHTML = `<div class="toast-title" style="color:${color}">${title}</div><div class="toast-desc">${msg}</div>`;
        document.getElementById('notification-area').appendChild(el);
        setTimeout(() => el.remove(), 3000);
    },
    showUpgrade: (tower) => {
        const p = document.getElementById('upgrade-panel');
        if(!tower) { p.classList.remove('active'); return; }
        
        p.classList.add('active');
        const info = TOWERS[tower.type];
        const upgCost = Math.floor(info.cost * 1.5 * tower.level);
        const maxLevel = 5;

        document.getElementById('upg-name').innerText = `${info.name} (Lvl ${tower.level})`;
        document.getElementById('upg-name').style.color = RARITY[info.rarity].color;
        
        document.getElementById('upg-lvl').innerText = `${tower.level}/${maxLevel}`;
        const dmg = Math.floor(info.damage * (1 + (tower.level-1)*0.2));
        document.getElementById('upg-dmg').innerText = dmg;
        document.getElementById('upg-rng').innerText = info.range;

        const btn = document.getElementById('btn-do-upgrade');
        if(tower.level >= maxLevel) {
            btn.innerText = "MAX LEVEL";
            btn.disabled = true;
            btn.style.background = "#555";
        } else {
            btn.innerText = `UPGRADE (${upgCost})`;
            btn.disabled = game.money < upgCost;
            btn.style.background = game.money < upgCost ? "#555" : "var(--neon-green)";
        }
    },
    updateWaveBtn: (state, timeLeft) => {
        const btn = document.getElementById('btn-wave-ctrl');
        const fill = document.getElementById('wave-timer-fill');
        const bar = document.getElementById('wave-timer-bar');
        
        if (state === 'active') {
            btn.innerText = "WAVE IN PROGRESS...";
            btn.classList.add('disabled');
            bar.style.display = 'none';
        } else if (state === 'cooldown') {
            btn.innerText = "SKIP TIMER >>";
            btn.classList.remove('disabled');
            bar.style.display = 'block';
            fill.style.width = (timeLeft / 300) * 100 + '%'; // 300 frames = 5s
        } else {
            btn.innerText = "INITIATE WAVE";
            btn.classList.remove('disabled');
            bar.style.display = 'none';
        }
    }
};

class Game {
    constructor() {
        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.cellSize = 40; this.cols = 20; this.rows = 15;
        this.grid = []; 
        this.startPos = {x:0, y:7}; this.endPos = {x:19, y:7};
        
        this.money = 500;
        this.lives = 20;
        this.wave = 1;
        
        this.inventory = ['wall', 'basic']; 
        this.towers = [];
        this.enemies = [];
        this.projectiles = [];
        this.effects = []; 
        
        this.pathfinder = new Pathfinder(this.cols, this.rows);
        this.cachedPath = [];
        
        this.selectedType = null;
        this.selectedTower = null; 
        this.mouse = {x:0, y:0, gx:0, gy:0};
        
        // WAVE LOGIC
        this.gameState = 'IDLE'; // IDLE, SPAWNING, ACTIVE, COOLDOWN
        this.spawnQueue = 0;
        this.spawnTimer = 0;
        this.waveCooldownTimer = 0;
        
        this.canvas.addEventListener('mousemove', e => this.onMove(e));
        this.canvas.addEventListener('click', () => this.onClick());
        window.addEventListener('resize', () => this.resize());
        this.resize();
    }

    resize() {
        const stage = document.getElementById('game-stage');
        this.cellSize = Math.floor(Math.min((stage.clientWidth-20)/this.cols, (stage.clientHeight-20)/this.rows));
        this.canvas.width = this.cellSize * this.cols;
        this.canvas.height = this.cellSize * this.rows;
    }

    start() {
        AudioSys.init();
        document.getElementById('start-screen').classList.add('hidden');
        this.grid = Array(this.cols).fill().map(()=>Array(this.rows).fill(0));
        this.updatePath();
        ui.renderInventory();
        this.updateStats();
        this.loop();
    }

    updatePath() {
        const p = this.pathfinder.findPath(this.grid, this.startPos, this.endPos);
        if(p) this.cachedPath = p;
        return p;
    }

    onMove(e) {
        const r = this.canvas.getBoundingClientRect();
        this.mouse.x = e.clientX - r.left; this.mouse.y = e.clientY - r.top;
        this.mouse.gx = Math.floor(this.mouse.x / this.cellSize);
        this.mouse.gy = Math.floor(this.mouse.y / this.cellSize);
    }

    selectTower(id) {
        AudioSys.sfx.click();
        this.selectedType = id;
        this.selectedTower = null;
        ui.showUpgrade(null);
        document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
        if(id) document.getElementById(`btn-${id}`).classList.add('selected');
    }

    onClick() {
        const {gx, gy} = this.mouse;
        if(gx < 0 || gx >= this.cols || gy < 0 || gy >= this.rows) return;

        const clickedTower = this.towers.find(t => t.x === gx && t.y === gy);
        if(clickedTower) {
            this.selectedTower = clickedTower;
            this.selectedType = null;
            document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
            ui.showUpgrade(clickedTower);
            AudioSys.sfx.click();
            return;
        }

        if(!this.selectedType) return;
        if(this.grid[gx][gy] !== 0) { AudioSys.sfx.error(); return; }
        if((gx==this.startPos.x && gy==this.startPos.y) || (gx==this.endPos.x && gy==this.endPos.y)) return;

        const info = TOWERS[this.selectedType];
        if(this.money < info.cost) { ui.toast('ERROR', 'Insufficient RAM', 'red'); AudioSys.sfx.error(); return; }

        this.grid[gx][gy] = 1;
        if(!this.updatePath()) {
            this.grid[gx][gy] = 0;
            this.updatePath();
            ui.toast('WARNING', 'Path Blocked', 'orange');
            AudioSys.sfx.error();
            return;
        }

        this.money -= info.cost;
        this.towers.push({
            x: gx, y: gy, type: this.selectedType,
            cd: 0, angle: 0, level: 1
        });
        AudioSys.sfx.place();
        this.enemies.forEach(e => e.repath());
        this.updateStats();
    }

    upgradeSelected() {
        if(!this.selectedTower) return;
        const t = this.selectedTower;
        const info = TOWERS[t.type];
        const cost = Math.floor(info.cost * 1.5 * t.level);
        
        if(t.level >= 5) return;
        if(this.money >= cost) {
            this.money -= cost;
            t.level++;
            AudioSys.sfx.upgrade();
            ui.showUpgrade(t); 
            this.updateStats();
            for(let i=0; i<10; i++) this.effects.push({x:t.x*this.cellSize+20, y:t.y*this.cellSize+20, r:0, maxR:30, color:'#0f0', vx:0});
        } else {
            AudioSys.sfx.error();
        }
    }

    sellSelected() {
        if(!this.selectedTower) return;
        const t = this.selectedTower;
        const info = TOWERS[t.type];
        const refund = Math.floor(info.cost * 0.7 * t.level); 
        
        this.money += refund;
        this.grid[t.x][t.y] = 0;
        this.towers = this.towers.filter(tw => tw !== t);
        
        this.selectedTower = null;
        ui.showUpgrade(null);
        AudioSys.sfx.sell();
        
        this.enemies.forEach(e => e.repath());
        this.updatePath();
        this.updateStats();
    }

    openCrate() {
        if(this.money < 500) { ui.toast('ERROR', 'Need 500 RAM', 'red'); return; }
        this.money -= 500;
        this.updateStats();
        AudioSys.sfx.gacha();

        const flash = document.getElementById('crate-flash');
        flash.style.animation = 'none'; flash.offsetHeight; flash.style.animation = 'flash 0.5s forwards';

        const rand = Math.random();
        let rarity = 'COMMON';
        if(rand > 0.99) rarity = 'MYTHIC';
        else if(rand > 0.95) rarity = 'LEGENDARY';
        else if(rand > 0.8) rarity = 'EPIC';
        else if(rand > 0.5) rarity = 'RARE';

        const pool = Object.keys(TOWERS).filter(k => TOWERS[k].rarity === rarity && k !== 'wall');
        const pick = pool[Math.floor(Math.random() * pool.length)];
        const towerInfo = TOWERS[pick];

        setTimeout(() => {
            if(!this.inventory.includes(pick)) {
                this.inventory.push(pick);
                ui.renderInventory();
                ui.toast(`UNLOCKED: ${towerInfo.name}`, `${rarity} Blueprint!`, RARITY[rarity].color);
            } else {
                this.money += 250;
                this.updateStats();
                ui.toast(`DUPLICATE: ${towerInfo.name}`, `Refunded 250 RAM`, RARITY[rarity].color);
            }
        }, 300);
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }

    waveControl() {
        // Can manually start from IDLE or skip COOLDOWN
        if (this.gameState === 'IDLE' || this.gameState === 'COOLDOWN') {
            this.startNextWave();
        }
    }

    startNextWave() {
        this.gameState = 'SPAWNING';
        this.spawnQueue = 5 + Math.floor(this.wave * 1.5);
        this.spawnTimer = 0;
        this.waveCooldownTimer = 0;
        ui.toast('SYSTEM', `Wave ${this.wave} Started`, '#0ff');
    }

    update() {
        // STATE MACHINE
        if (this.gameState === 'SPAWNING') {
            this.spawnTimer++;
            if (this.spawnTimer > 40) {
                this.spawnEnemy();
                this.spawnQueue--;
                this.spawnTimer = 0;
                if (this.spawnQueue <= 0) this.gameState = 'ACTIVE';
            }
            ui.updateWaveBtn('active');
        } 
        else if (this.gameState === 'ACTIVE') {
            if (this.enemies.length === 0) {
                this.gameState = 'COOLDOWN';
                this.waveCooldownTimer = 300; // 5 seconds (60fps * 5)
                this.wave++;
                this.money += 200 + (this.wave * 20);
                this.updateStats();
                ui.toast('CLEAR', 'Wave Complete. RAM allocated.', '#0f0');
            }
            ui.updateWaveBtn('active');
        }
        else if (this.gameState === 'COOLDOWN') {
            this.waveCooldownTimer--;
            if (this.waveCooldownTimer <= 0) {
                this.startNextWave();
            }
            ui.updateWaveBtn('cooldown', this.waveCooldownTimer);
        } else {
            ui.updateWaveBtn('idle');
        }

        // Enemies
        for(let i=this.enemies.length-1; i>=0; i--) {
            let e = this.enemies[i];
            let speed = e.speed;
            if(e.slow > 0) { speed *= 0.5; e.slow--; }
            if(e.stun > 0) { speed = 0; e.stun--; }
            
            if(e.path && e.pIdx < e.path.length) {
                let target = e.path[e.pIdx];
                let tx = target.x*this.cellSize + this.cellSize/2;
                let ty = target.y*this.cellSize + this.cellSize/2;
                let dx = tx - e.x, dy = ty - e.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if(dist < speed) { e.x = tx; e.y = ty; e.pIdx++; }
                else { e.x += (dx/dist)*speed; e.y += (dy/dist)*speed; }
            }
            if(Math.hypot(e.x - (this.endPos.x*this.cellSize+20), e.y - (this.endPos.y*this.cellSize+20)) < 10) {
                this.lives--; this.enemies.splice(i, 1); this.updateStats(); AudioSys.sfx.error();
                if(this.lives <= 0) document.getElementById('game-over-screen').classList.remove('hidden');
            }
        }

        // Towers
        this.towers.forEach(t => {
            if(t.type === 'wall') return;
            const info = TOWERS[t.type];
            let buffRate = 1;
            if(t.type !== 'buffer') {
                 this.towers.forEach(nt => {
                     if(nt.type === 'buffer') {
                         const dist = Math.hypot(nt.x - t.x, nt.y - t.y);
                         const buffRange = TOWERS['buffer'].range * (1 + (nt.level-1)*0.1) * this.cellSize;
                         if(dist <= buffRange) buffRate = 1.5;
                     }
                 });
            }

            if(t.cd > 0) t.cd -= buffRate;
            else {
                if(info.type === 'passive') {
                    if(info.effect === 'income') {
                        this.money += 5 * t.level;
                        this.addFloatText(t.x, t.y, `+$${5*t.level}`, 'yellow');
                        t.cd = info.rate; 
                        this.updateStats();
                    }
                    return;
                }

                let range = info.range * (1 + (t.level-1)*0.1); 
                let damage = info.damage * (1 + (t.level-1)*0.2); 

                let target = null;
                
                // Special Targeting for Orbital (Global)
                if(info.effect === 'global') {
                     if(this.enemies.length > 0) target = this.enemies[Math.floor(Math.random() * this.enemies.length)];
                } else {
                     target = this.enemies.find(e => Math.hypot(e.x - (t.x*this.cellSize+20), e.y - (t.y*this.cellSize+20)) < range*this.cellSize);
                }

                if(target) {
                    t.cd = info.rate;
                    t.angle = Math.atan2(target.y - (t.y*this.cellSize+20), target.x - (t.x*this.cellSize+20));
                    if(info.rarity!=='MYTHIC') AudioSys.sfx.shoot();

                    if(info.effect === 'farm') { this.money += 2; this.updateStats(); }
                    
                    if(info.effect === 'spread') {
                        for(let i=-1; i<=1; i++) {
                            this.projectiles.push({sx: t.x*this.cellSize+20, sy: t.y*this.cellSize+20, tx: target.x+i*20, ty: target.y+i*20, color: '#0f9', life: 10, width: 2});
                        }
                        target.hp -= damage;
                    }
                    else if(info.effect === 'pierce') {
                        this.enemies.forEach(e => {
                             if(Math.hypot(e.x - (t.x*this.cellSize+20), e.y - (t.y*this.cellSize+20)) < range*this.cellSize) {
                                 if(Math.abs(Math.atan2(e.y-(t.y*this.cellSize+20), e.x-(t.x*this.cellSize+20)) - t.angle) < 0.2) {
                                     e.hp -= damage;
                                 }
                             }
                        });
                        this.projectiles.push({sx: t.x*this.cellSize+20, sy: t.y*this.cellSize+20, tx: target.x, ty: target.y, color: '#f0f', life: 5, width: 4});
                    }
                    else if(info.effect === 'splash') {
                        this.projectiles.push({sx: t.x*this.cellSize+20, sy: t.y*this.cellSize+20, tx: target.x, ty: target.y, color: '#f00', life: 10, width: 3});
                        this.effects.push({x:target.x, y:target.y, r:0, maxR:50, color:'orange'});
                        this.enemies.forEach(subE => {
                            if(Math.hypot(subE.x - target.x, subE.y - target.y) < 50) subE.hp -= damage;
                        });
                        AudioSys.sfx.boom();
                    }
                    else if(info.effect === 'teleport') {
                        // Portal
                        AudioSys.sfx.portal();
                        this.projectiles.push({sx: t.x*this.cellSize+20, sy: t.y*this.cellSize+20, tx: target.x, ty: target.y, color: '#0ff', life: 5, width: 2});
                        // Teleport back 20% of path or 10 nodes
                        const backStep = Math.max(0, target.pIdx - 5);
                        if(target.path[backStep]) {
                             const oldX = target.x; const oldY = target.y;
                             target.pIdx = backStep;
                             target.x = target.path[backStep].x * this.cellSize + 20;
                             target.y = target.path[backStep].y * this.cellSize + 20;
                             this.effects.push({x:oldX, y:oldY, r:0, maxR:30, color:'#0ff'});
                             this.effects.push({x:target.x, y:target.y, r:0, maxR:30, color:'#0ff'});
                        }
                        target.hp -= damage;
                    }
                    else if(info.effect === 'global') {
                        // Orbital
                        AudioSys.sfx.boom();
                        this.effects.push({x:target.x, y:target.y, r:0, maxR:40, color:'#ff2a6d'});
                        this.projectiles.push({sx: target.x, sy: 0, tx: target.x, ty: target.y, color: '#ff2a6d', life: 10, width: 4}); // Beam from sky
                        target.hp -= damage;
                    }
                    else if(info.effect === 'stun') {
                        target.stun = 20; 
                        target.hp -= damage;
                         this.projectiles.push({sx: t.x*this.cellSize+20, sy: t.y*this.cellSize+20, tx: target.x, ty: target.y, color: '#ff0', life: 5, width: 2});
                    }
                    else if(info.effect === 'chaos') {
                        const dmg = Math.random() * 200;
                        target.hp -= dmg;
                        this.addFloatText(target.x/this.cellSize, target.y/this.cellSize, Math.floor(dmg), 'white');
                        this.projectiles.push({sx: t.x*this.cellSize+20, sy: t.y*this.cellSize+20, tx: target.x, ty: target.y, color: '#fff', life: 5, width: 1});
                    }
                    else if(info.effect === 'chain') {
                        let chain = [target];
                        for(let k=0; k<2; k++) {
                            let last = chain[chain.length-1];
                            let next = this.enemies.find(ne => !chain.includes(ne) && Math.hypot(ne.x-last.x, ne.y-last.y) < 100);
                            if(next) chain.push(next);
                        }
                        chain.forEach(c => {
                             c.hp -= damage;
                             if(c.hp<=0) this.killEnemy(c);
                        });
                        for(let k=0; k<chain.length-1; k++) {
                            this.projectiles.push({sx:chain[k].x, sy:chain[k].y, tx:chain[k+1].x, ty:chain[k+1].y, color:'#0ff', life:5, width:2});
                        }
                        this.projectiles.push({sx:t.x*this.cellSize+20, sy:t.y*this.cellSize+20, tx:target.x, ty:target.y, color:'#0ff', life:5, width:2});
                    }
                    else if(info.effect === 'suck') {
                        this.enemies.forEach(subE => {
                            if(Math.hypot(subE.x - target.x, subE.y - target.y) < 100) {
                                subE.speed *= 0.2; 
                                subE.hp -= damage;
                            }
                        });
                        this.effects.push({x:target.x, y:target.y, r:0, maxR:60, color:'#9400d3'});
                    }
                    else if(info.effect === 'nuke') {
                        AudioSys.sfx.boom();
                        this.enemies.forEach(subE => {
                            if(Math.hypot(subE.x - target.x, subE.y - target.y) < 150) subE.hp -= damage;
                        });
                        this.effects.push({x:target.x, y:target.y, r:0, maxR:100, color:'#ff0'});
                    }
                    else {
                        target.hp -= damage;
                        if(info.effect === 'slow') target.slow = 100;
                        if(info.effect === 'burn') target.burn = 200;
                        this.projectiles.push({sx: t.x*this.cellSize+20, sy: t.y*this.cellSize+20, tx: target.x, ty: target.y, color: RARITY[info.rarity].color, life: 5, width: 2});
                    }
                    if(target.hp <= 0) this.killEnemy(target);
                }
            }
        });

        this.projectiles = this.projectiles.filter(p => p.life-- > 0);
        this.effects = this.effects.filter(e => { e.r+=2; return e.r < e.maxR; });
        this.floatText = this.floatText?.filter(f => f.life-- > 0) || [];
    }

    spawnEnemy() {
        const hp = 50 + (this.wave*30);
        this.enemies.push({
            x: this.startPos.x*this.cellSize+20, y: this.startPos.y*this.cellSize+20,
            hp: hp, maxHp: hp, speed: 2 + (this.wave*0.1),
            path: [...this.cachedPath], pIdx: 0, slow: 0, burn: 0, stun: 0,
            repath: function() { this.path = game.pathfinder.findPath(game.grid, {x:Math.floor(this.x/game.cellSize), y:Math.floor(this.y/game.cellSize)}, game.endPos); this.pIdx = 0; }
        });
    }

    killEnemy(e) {
        if(this.enemies.indexOf(e) === -1) return;
        this.enemies = this.enemies.filter(en => en !== e);
        this.money += 15;
        this.updateStats();
        AudioSys.sfx.boom();
        for(let i=0; i<5; i++) this.effects.push({x:e.x, y:e.y, r:0, maxR: 20, color: 'orange'});
    }

    addFloatText(gx, gy, text, color) {
        if(!this.floatText) this.floatText = [];
        this.floatText.push({x: gx*this.cellSize+20, y: gy*this.cellSize, text: text, color: color, life: 30});
    }

    updateStats() {
        document.getElementById('val-money').innerText = this.money;
        document.getElementById('val-health').innerText = (this.lives * 5) + "%";
        document.getElementById('val-wave').innerText = this.wave;
        document.getElementById('final-wave').innerText = this.wave;
        if(this.selectedTower) ui.showUpgrade(this.selectedTower);
        
        document.querySelectorAll('.tower-btn').forEach(btn => {
            const id = btn.id.replace('btn-', '');
            if(TOWERS[id] && this.money < TOWERS[id].cost && id !== 'recycle') btn.classList.add('disabled');
            else btn.classList.remove('disabled');
        });
    }

    draw() {
        this.ctx.fillStyle = '#0a0a12'; this.ctx.fillRect(0,0,this.canvas.width, this.canvas.height);

        this.ctx.strokeStyle = '#1a1a2e'; this.ctx.lineWidth = 1; this.ctx.beginPath();
        for(let i=0; i<=this.cols; i++) { this.ctx.moveTo(i*this.cellSize,0); this.ctx.lineTo(i*this.cellSize,this.canvas.height); }
        for(let i=0; i<=this.rows; i++) { this.ctx.moveTo(0,i*this.cellSize); this.ctx.lineTo(this.canvas.width,i*this.cellSize); }
        this.ctx.stroke();

        this.ctx.fillStyle = 'rgba(0,255,0,0.1)'; this.ctx.fillRect(this.startPos.x*this.cellSize, this.startPos.y*this.cellSize, this.cellSize, this.cellSize);
        this.ctx.fillStyle = 'rgba(255,0,0,0.1)'; this.ctx.fillRect(this.endPos.x*this.cellSize, this.endPos.y*this.cellSize, this.cellSize, this.cellSize);

        if(this.cachedPath.length > 0) {
            this.ctx.beginPath(); this.ctx.strokeStyle = 'rgba(255,255,255,0.05)'; this.ctx.lineWidth = 10;
            let sx = this.startPos.x*this.cellSize+20, sy = this.startPos.y*this.cellSize+20;
            this.ctx.moveTo(sx, sy);
            this.cachedPath.forEach(p => this.ctx.lineTo(p.x*this.cellSize+20, p.y*this.cellSize+20));
            this.ctx.stroke();
        }

        this.towers.forEach(t => {
            const x = t.x*this.cellSize, y = t.y*this.cellSize;
            const info = TOWERS[t.type];
            this.ctx.save();
            this.ctx.translate(x+20, y+20);
            
            this.ctx.fillStyle = RARITY[info.rarity].color;
            for(let i=0; i<t.level; i++) {
                this.ctx.fillRect(-18 + (i*4), -18, 3, 3);
            }

            this.ctx.rotate(t.angle);
            info.draw(this.ctx, this.cellSize);
            this.ctx.restore();
            
            if(t === this.selectedTower) {
                this.ctx.strokeStyle = '#fff'; this.ctx.lineWidth = 2; 
                this.ctx.strokeRect(x,y,this.cellSize,this.cellSize);
                const rangeVal = info.range*(1+(t.level-1)*0.1)*this.cellSize;
                this.ctx.beginPath(); this.ctx.strokeStyle='rgba(255,255,255,0.2)'; 
                this.ctx.arc(x+20,y+20, rangeVal, 0, Math.PI*2); 
                this.ctx.stroke();
                
                if(t.type === 'buffer') {
                    this.ctx.strokeStyle = '#0f0'; this.ctx.lineWidth = 2;
                    this.towers.forEach(other => {
                        if(other === t) return;
                        if(Math.hypot(other.x - t.x, other.y - t.y) <= info.range*(1+(t.level-1)*0.1)) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(x+20, y+20);
                            this.ctx.lineTo(other.x*this.cellSize+20, other.y*this.cellSize+20);
                            this.ctx.stroke();
                        }
                    });
                }
            }
        });

        this.enemies.forEach(e => {
            this.ctx.fillStyle = e.slow > 0 ? '#00f' : (e.stun > 0 ? '#ff0' : '#fff');
            this.ctx.beginPath(); this.ctx.arc(e.x, e.y, 6, 0, Math.PI*2); this.ctx.fill();
            this.ctx.fillStyle = 'red'; this.ctx.fillRect(e.x-8, e.y-12, 16, 3);
            this.ctx.fillStyle = '#0f0'; this.ctx.fillRect(e.x-8, e.y-12, 16 * (e.hp/e.maxHp), 3);
        });

        this.projectiles.forEach(p => {
             this.ctx.strokeStyle = p.color; this.ctx.lineWidth = p.width;
             this.ctx.beginPath(); this.ctx.moveTo(p.sx, p.sy); this.ctx.lineTo(p.tx, p.ty); this.ctx.stroke();
        });

        this.effects.forEach(e => {
            this.ctx.strokeStyle = e.color; this.ctx.lineWidth = 1;
            this.ctx.beginPath(); this.ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); this.ctx.stroke();
        });

        if(this.floatText) {
            this.ctx.font = '10px monospace';
            this.floatText.forEach(f => {
                this.ctx.fillStyle = f.color;
                this.ctx.fillText(f.text, f.x, f.y - (30-f.life));
            });
        }

        if(this.selectedType && this.mouse.gx >= 0 && this.mouse.gx < this.cols && this.mouse.gy >= 0 && this.mouse.gy < this.rows) {
            const cx = this.mouse.gx * this.cellSize, cy = this.mouse.gy * this.cellSize;
            const info = TOWERS[this.selectedType];
            this.ctx.save(); this.ctx.translate(cx+20, cy+20);
            this.ctx.globalAlpha = 0.5;
            info.draw(this.ctx, this.cellSize);
            this.ctx.restore(); this.ctx.globalAlpha = 1;
            
            this.ctx.beginPath(); this.ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            this.ctx.arc(cx+20, cy+20, info.range*this.cellSize, 0, Math.PI*2); this.ctx.stroke();
        }
    }
}

window.onload = () => { window.game = new Game(); };

</script>
</body>
</html>
