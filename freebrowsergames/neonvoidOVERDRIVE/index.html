<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Void: Overdrive</title>
    <meta name="description" content="High-performance HTML5 Arcade Shooter">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        :root {
            --neon-blue: #00f3ff;
            --neon-pink: #ff00ff;
            --neon-green: #00ff66;
            --neon-red: #ff3333;
            --bg-dark: #050510;
            --glass: rgba(10, 20, 40, 0.85);
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: 'Orbitron', sans-serif;
            color: white;
            height: 100vh;
            width: 100vw;
        }

        /* Scanline Effect */
        body::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlay Layer */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
        }

        /* HUD */
        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            text-shadow: 0 0 10px var(--neon-blue);
        }

        .score-box {
            font-size: 1.5rem;
            color: var(--neon-blue);
        }
        
        .wave-box {
            font-size: 2rem;
            font-weight: 900;
            color: var(--neon-pink);
            text-align: center;
        }

        .health-bar-container {
            width: 200px;
            height: 20px;
            border: 2px solid var(--neon-green);
            border-radius: 4px;
            overflow: hidden;
            background: rgba(0,0,0,0.5);
            box-shadow: 0 0 10px var(--neon-green);
        }

        #health-fill {
            width: 100%;
            height: 100%;
            background: var(--neon-green);
            transition: width 0.2s;
        }

        /* Interactive Screens (Start, Shop, Game Over) */
        .screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--glass);
            border: 2px solid var(--neon-blue);
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.2);
            backdrop-filter: blur(10px);
            pointer-events: auto;
            display: none;
            min-width: 300px;
        }

        .screen.active {
            display: flex;
            flex-direction: column;
            gap: 20px;
            animation: fadeIn 0.3s ease-out;
        }

        h1 {
            margin: 0;
            font-size: 3rem;
            background: linear-gradient(to right, var(--neon-blue), var(--neon-pink));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            letter-spacing: 4px;
        }

        button {
            background: transparent;
            border: 2px solid var(--neon-blue);
            color: var(--neon-blue);
            padding: 15px 30px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        button:hover {
            background: var(--neon-blue);
            color: black;
            box-shadow: 0 0 20px var(--neon-blue);
        }

        button:active {
            transform: scale(0.95);
        }

        /* Shop Grid */
        .shop-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .upgrade-card {
            border: 1px solid rgba(255,255,255,0.2);
            padding: 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: 0.2s;
            background: rgba(0,0,0,0.3);
        }

        .upgrade-card:hover {
            border-color: var(--neon-green);
            background: rgba(0, 255, 102, 0.1);
        }

        .upgrade-card h3 { margin: 0 0 5px 0; font-size: 1rem; color: var(--neon-green); }
        .upgrade-card p { margin: 0; font-size: 0.8rem; color: #aaa; }
        .upgrade-card .cost { display: block; margin-top: 5px; font-weight: bold; color: var(--neon-pink); }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -45%); }
            to { opacity: 1; transform: translate(-50%, -50%); }
        }

        /* Mobile Controls */
        #mobile-controls {
            display: none; /* Shown via JS on touch devices */
            position: absolute;
            bottom: 20px;
            width: 100%;
            justify-content: space-around;
            pointer-events: none;
        }
        .joystick-area {
            width: 120px;
            height: 120px;
            background: rgba(255,255,255,0.05);
            border-radius: 50%;
            border: 1px dashed rgba(255,255,255,0.2);
            pointer-events: auto;
            position: relative;
        }
        .fire-btn {
            width: 80px;
            height: 80px;
            background: rgba(255, 51, 51, 0.2);
            border: 2px solid var(--neon-red);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @media (max-width: 768px) {
            h1 { font-size: 2rem; }
            .shop-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <!-- UI Layer -->
    <div id="ui-layer">
        <div class="hud-top">
            <div class="score-container">
                <div class="score-box">SCORE: <span id="score-display">0</span></div>
                <div style="font-size: 0.8rem; color: #888;">HIGH: <span id="high-score-display">0</span></div>
            </div>
            <div class="wave-box">WAVE <span id="wave-display">1</span></div>
            <div class="health-container">
                <div style="text-align: right; margin-bottom: 2px; font-size: 0.8rem;">SHIELD INTEGRITY</div>
                <div class="health-bar-container">
                    <div id="health-fill"></div>
                </div>
            </div>
        </div>

        <div id="mobile-controls">
            <div id="joystick" class="joystick-area"></div>
            <div id="fireBtn" class="fire-btn">FIRE</div>
        </div>
    </div>

    <!-- START SCREEN -->
    <div id="start-screen" class="screen active">
        <h1>NEON VOID<br><span style="font-size: 1.5rem; letter-spacing: 8px; color: white;">OVERDRIVE</span></h1>
        <p>WASD / Arrows to Move â€¢ Mouse to Aim & Shoot</p>
        <button onclick="game.start()">Initialize System</button>
    </div>

    <!-- UPGRADE SHOP -->
    <div id="shop-screen" class="screen">
        <h2>System Upgrade</h2>
        <div class="points-avail" style="margin-bottom: 10px;">Credits Available: <span id="shop-credits" style="color:var(--neon-blue)">0</span></div>
        <div class="shop-grid">
            <div class="upgrade-card" onclick="game.upgrade('fireRate')">
                <h3>Rapid Fire</h3>
                <p>Increase projectile output speed.</p>
                <span class="cost" id="cost-fireRate">1000 CR</span>
            </div>
            <div class="upgrade-card" onclick="game.upgrade('damage')">
                <h3>Plasma Potency</h3>
                <p>Increase damage per hit.</p>
                <span class="cost" id="cost-damage">1500 CR</span>
            </div>
            <div class="upgrade-card" onclick="game.upgrade('speed')">
                <h3>Thrusters</h3>
                <p>Increase movement speed.</p>
                <span class="cost" id="cost-speed">800 CR</span>
            </div>
            <div class="upgrade-card" onclick="game.upgrade('health')">
                <h3>Hull Repair</h3>
                <p>Restore 50% Integrity.</p>
                <span class="cost" id="cost-health">500 CR</span>
            </div>
        </div>
        <button style="margin-top: 20px;" onclick="game.nextWave()">Engage Next Wave</button>
    </div>

    <!-- GAME OVER -->
    <div id="game-over-screen" class="screen">
        <h1 style="color: var(--neon-red);">CRITICAL FAILURE</h1>
        <p>System integrity compromised.</p>
        <p style="font-size: 1.5rem;">Final Score: <span id="final-score">0</span></p>
        <button onclick="game.reset()">Reboot System</button>
    </div>
</div>

<script>
/**
 * AUDIO ENGINE
 * Synthesizes retro sound effects on the fly using Web Audio API.
 * No external assets required.
 */
class SoundEngine {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.enabled = true;
    }

    playTone(freq, type, duration, vol = 0.1) {
        if (!this.enabled) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    shoot() { this.playTone(800, 'square', 0.1, 0.05); }
    hit() { this.playTone(200, 'sawtooth', 0.1, 0.05); }
    explosion() { 
        // Noise simulation for explosion
        if (!this.enabled) return;
        const bufferSize = this.ctx.sampleRate * 0.5; // 0.5 sec
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
        
        noise.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
    }
    upgrade() { this.playTone(1200, 'sine', 0.3, 0.1); }
}

/**
 * MATH HELPERS
 */
const Vec2 = {
    add: (v1, v2) => ({x: v1.x + v2.x, y: v1.y + v2.y}),
    sub: (v1, v2) => ({x: v1.x - v2.x, y: v1.y - v2.y}),
    mult: (v, s) => ({x: v.x * s, y: v.y * s}),
    mag: (v) => Math.sqrt(v.x * v.x + v.y * v.y),
    norm: (v) => {
        const m = Math.sqrt(v.x * v.x + v.y * v.y);
        return m === 0 ? {x: 0, y: 0} : {x: v.x / m, y: v.y / m};
    },
    dist: (v1, v2) => Math.sqrt(Math.pow(v2.x - v1.x, 2) + Math.pow(v2.y - v1.y, 2)),
    angle: (v1, v2) => Math.atan2(v2.y - v1.y, v2.x - v1.x)
};

/**
 * ENTITY SYSTEM
 * Base classes for game objects.
 */
class Entity {
    constructor(x, y, radius, color) {
        this.pos = {x, y};
        this.vel = {x: 0, y: 0};
        this.radius = radius;
        this.color = color;
        this.dead = false;
        this.angle = 0;
    }

    update(dt) {
        this.pos.x += this.vel.x * dt;
        this.pos.y += this.vel.y * dt;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        ctx.rotate(this.angle);
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        this.drawShape(ctx);
        ctx.restore();
    }

    drawShape(ctx) {
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fill();
    }
}

class Particle extends Entity {
    constructor(x, y, color, speed, life) {
        super(x, y, Math.random() * 2 + 1, color);
        const angle = Math.random() * Math.PI * 2;
        this.vel = {
            x: Math.cos(angle) * speed * Math.random(),
            y: Math.sin(angle) * speed * Math.random()
        };
        this.life = life;
        this.maxLife = life;
    }

    update(dt) {
        super.update(dt);
        this.life -= dt;
        if (this.life <= 0) this.dead = true;
    }

    draw(ctx) {
        ctx.globalAlpha = this.life / this.maxLife;
        super.draw(ctx);
        ctx.globalAlpha = 1;
    }
}

class Bullet extends Entity {
    constructor(x, y, angle, speed, damage, isEnemy = false) {
        super(x, y, 4, isEnemy ? '#ff3333' : '#00f3ff');
        this.vel = {
            x: Math.cos(angle) * speed,
            y: Math.sin(angle) * speed
        };
        this.damage = damage;
        this.isEnemy = isEnemy;
    }

    update(dt) {
        super.update(dt);
        // Bounds check
        if (this.pos.x < 0 || this.pos.x > window.innerWidth || 
            this.pos.y < 0 || this.pos.y > window.innerHeight) {
            this.dead = true;
        }
    }
    
    drawShape(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.rect(-4, -2, 8, 4);
        ctx.fill();
    }
}

class Enemy extends Entity {
    constructor(type, target) {
        super(0, 0, 0, '#ff00ff'); // Defaults overridden by type
        this.target = target;
        this.type = type;
        this.hp = 1;
        this.scoreValue = 100;
        this.shootTimer = 0;
        
        // Spawn logic
        const side = Math.floor(Math.random() * 4); // 0:top, 1:right, 2:bottom, 3:left
        if (side === 0) { this.pos = {x: Math.random() * window.innerWidth, y: -50}; }
        else if (side === 1) { this.pos = {x: window.innerWidth + 50, y: Math.random() * window.innerHeight}; }
        else if (side === 2) { this.pos = {x: Math.random() * window.innerWidth, y: window.innerHeight + 50}; }
        else { this.pos = {x: -50, y: Math.random() * window.innerHeight}; }

        // Type definitions
        if (type === 'drone') {
            this.radius = 15;
            this.hp = 30;
            this.speed = 100;
            this.color = '#ff3333';
            this.scoreValue = 50;
        } else if (type === 'tank') {
            this.radius = 25;
            this.hp = 100;
            this.speed = 40;
            this.color = '#ff9900';
            this.scoreValue = 150;
        } else if (type === 'rusher') {
            this.radius = 10;
            this.hp = 15;
            this.speed = 250;
            this.color = '#ff00ff';
            this.scoreValue = 80;
        }
    }

    update(dt, bulletsArray) {
        // AI Logic
        const dist = Vec2.dist(this.pos, this.target.pos);
        const dir = Vec2.norm(Vec2.sub(this.target.pos, this.pos));
        
        this.angle = Math.atan2(dir.y, dir.x);

        if (this.type === 'rusher') {
            // Rush player
            this.vel = Vec2.mult(dir, this.speed);
        } else if (this.type === 'drone') {
            // Keep distance and shoot
            if (dist > 300) {
                this.vel = Vec2.mult(dir, this.speed);
            } else {
                this.vel = {x:0, y:0};
            }
            
            this.shootTimer += dt;
            if (this.shootTimer > 2) {
                bulletsArray.push(new Bullet(this.pos.x, this.pos.y, this.angle, 300, 10, true));
                this.shootTimer = 0;
            }
        } else if (this.type === 'tank') {
            // Slow move
            this.vel = Vec2.mult(dir, this.speed);
            this.shootTimer += dt;
            if (this.shootTimer > 3) {
                // Shotgun spread
                for(let i = -0.3; i <= 0.3; i+=0.3) {
                     bulletsArray.push(new Bullet(this.pos.x, this.pos.y, this.angle + i, 200, 20, true));
                }
                this.shootTimer = 0;
            }
        }

        super.update(dt);
    }

    drawShape(ctx) {
        ctx.beginPath();
        if (this.type === 'rusher') {
            ctx.moveTo(10, 0);
            ctx.lineTo(-10, 7);
            ctx.lineTo(-10, -7);
        } else if (this.type === 'tank') {
            ctx.rect(-15, -15, 30, 30);
        } else {
            ctx.moveTo(15, 0);
            ctx.lineTo(-10, 10);
            ctx.lineTo(-5, 0);
            ctx.lineTo(-10, -10);
        }
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
    }
}

class Player extends Entity {
    constructor() {
        super(window.innerWidth/2, window.innerHeight/2, 20, '#00f3ff');
        this.speed = 300;
        this.maxHealth = 100;
        this.health = 100;
        this.fireRate = 0.2; // Seconds between shots
        this.damage = 25;
        this.fireTimer = 0;
        this.stats = {
            fireRateLvl: 1,
            damageLvl: 1,
            speedLvl: 1
        };
    }

    update(dt, input, bulletsArray, sound) {
        // Movement
        this.vel = {x: 0, y: 0};
        if (input.keys['KeyW'] || input.keys['ArrowUp']) this.vel.y = -this.speed;
        if (input.keys['KeyS'] || input.keys['ArrowDown']) this.vel.y = this.speed;
        if (input.keys['KeyA'] || input.keys['ArrowLeft']) this.vel.x = -this.speed;
        if (input.keys['KeyD'] || input.keys['ArrowRight']) this.vel.x = this.speed;

        super.update(dt);

        // Bounds
        this.pos.x = Math.max(this.radius, Math.min(window.innerWidth - this.radius, this.pos.x));
        this.pos.y = Math.max(this.radius, Math.min(window.innerHeight - this.radius, this.pos.y));

        // Aiming
        this.angle = Math.atan2(input.mouse.y - this.pos.y, input.mouse.x - this.pos.x);

        // Shooting
        this.fireTimer -= dt;
        if ((input.mouseDown || input.keys['Space']) && this.fireTimer <= 0) {
            this.shoot(bulletsArray, sound);
        }
    }

    shoot(bulletsArray, sound) {
        bulletsArray.push(new Bullet(this.pos.x, this.pos.y, this.angle, 800, this.damage));
        this.fireTimer = this.fireRate;
        sound.shoot();
        
        // Recoil
        this.pos.x -= Math.cos(this.angle) * 5;
        this.pos.y -= Math.sin(this.angle) * 5;
    }

    drawShape(ctx) {
        // Draw Ship
        ctx.beginPath();
        ctx.moveTo(20, 0);
        ctx.lineTo(-15, 15);
        ctx.lineTo(-5, 0);
        ctx.lineTo(-15, -15);
        ctx.closePath();
        ctx.fillStyle = '#000';
        ctx.fill();
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.stroke();

        // Engine Glow
        ctx.beginPath();
        ctx.moveTo(-15, 5);
        ctx.lineTo(-25, 0);
        ctx.lineTo(-15, -5);
        ctx.fillStyle = '#00ffff';
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 20;
        ctx.fill();
    }
}

/**
 * GAME CORE
 */
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.sound = new SoundEngine();
        
        this.entities = {
            player: null,
            bullets: [],
            enemies: [],
            particles: []
        };
        
        this.state = 'MENU'; // MENU, PLAYING, SHOP, GAMEOVER
        this.wave = 1;
        this.score = 0;
        this.highScore = localStorage.getItem('neon_high') || 0;
        document.getElementById('high-score-display').innerText = this.highScore;

        this.input = {
            keys: {},
            mouse: {x: 0, y: 0},
            mouseDown: false
        };

        this.waveConfig = {
            toSpawn: 0,
            spawnTimer: 0,
            spawnRate: 1
        };

        this.lastTime = 0;
        
        this.bindEvents();
        this.resize();
        
        // Stars
        this.stars = [];
        for(let i=0; i<100; i++) {
            this.stars.push({
                x: Math.random() * this.canvas.width,
                y: Math.random() * this.canvas.height,
                size: Math.random() * 2,
                speed: Math.random() * 0.5 + 0.1
            });
        }

        // Start Loop
        requestAnimationFrame((t) => this.loop(t));
    }

    bindEvents() {
        window.addEventListener('resize', () => this.resize());
        
        window.addEventListener('keydown', (e) => this.input.keys[e.code] = true);
        window.addEventListener('keyup', (e) => this.input.keys[e.code] = false);
        
        window.addEventListener('mousemove', (e) => {
            this.input.mouse.x = e.clientX;
            this.input.mouse.y = e.clientY;
        });
        window.addEventListener('mousedown', () => this.input.mouseDown = true);
        window.addEventListener('mouseup', () => this.input.mouseDown = false);

        // Mobile
        const joy = document.getElementById('joystick');
        const fire = document.getElementById('fireBtn');
        
        // Simple Touch logic would go here (omitted for brevity in this specific block but structure is there)
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }

    start() {
        // Init Game
        this.entities.player = new Player();
        this.entities.bullets = [];
        this.entities.enemies = [];
        this.entities.particles = [];
        this.score = 0;
        this.wave = 1;
        
        // Hide Screens
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        
        // Start Sound context if needed (browser policy)
        if (this.sound.ctx.state === 'suspended') this.sound.ctx.resume();

        this.startWave();
        this.state = 'PLAYING';
    }

    startWave() {
        this.waveConfig.toSpawn = 5 + (this.wave * 2);
        this.waveConfig.spawnRate = Math.max(0.2, 1.5 - (this.wave * 0.1));
        document.getElementById('wave-display').innerText = this.wave;
        this.showToast(`WAVE ${this.wave} INITIATED`);
    }

    showToast(msg) {
        // Simple canvas toast or DOM? Let's use DOM for simplicity
        const toast = document.createElement('div');
        toast.innerText = msg;
        toast.style.position = 'absolute';
        toast.style.top = '30%';
        toast.style.left = '50%';
        toast.style.transform = 'translate(-50%, -50%)';
        toast.style.fontSize = '3rem';
        toast.style.color = '#fff';
        toast.style.textShadow = '0 0 20px var(--neon-pink)';
        toast.style.fontWeight = 'bold';
        toast.style.pointerEvents = 'none';
        toast.style.animation = 'fadeIn 0.5s forwards';
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), 2000);
    }

    loop(timestamp) {
        const dt = Math.min((timestamp - this.lastTime) / 1000, 0.1); // Cap dt
        this.lastTime = timestamp;

        if (this.state === 'PLAYING') {
            this.update(dt);
        }
        this.draw();

        requestAnimationFrame((t) => this.loop(t));
    }

    update(dt) {
        const { player, bullets, enemies, particles } = this.entities;

        // Player
        if (player.dead) {
            this.gameOver();
            return;
        }
        player.update(dt, this.input, bullets, this.sound);

        // Spawner
        if (this.waveConfig.toSpawn > 0) {
            this.waveConfig.spawnTimer -= dt;
            if (this.waveConfig.spawnTimer <= 0) {
                const types = ['drone', 'drone', 'rusher', 'tank'];
                // Difficulty scaling: add harder enemies later
                const type = types[Math.floor(Math.random() * Math.min(types.length, 1 + this.wave/2))];
                enemies.push(new Enemy(type, player));
                this.waveConfig.toSpawn--;
                this.waveConfig.spawnTimer = this.waveConfig.spawnRate;
            }
        } else if (enemies.length === 0) {
            this.openShop();
        }

        // Entities
        bullets.forEach(b => b.update(dt));
        enemies.forEach(e => e.update(dt, bullets));
        particles.forEach(p => p.update(dt));

        // Cleanup
        this.entities.bullets = bullets.filter(b => !b.dead);
        this.entities.enemies = enemies.filter(e => !e.dead);
        this.entities.particles = particles.filter(p => !p.dead);

        // Collisions
        this.checkCollisions();
        
        // UI Updates
        document.getElementById('health-fill').style.width = `${Math.max(0, player.health)}%`;
        document.getElementById('score-display').innerText = this.score;
        document.getElementById('shop-credits').innerText = this.score; // Score = Credits
    }

    spawnParticles(x, y, color, count) {
        for(let i=0; i<count; i++) {
            this.entities.particles.push(new Particle(x, y, color, 100, 0.5));
        }
    }

    checkCollisions() {
        const { player, bullets, enemies } = this.entities;

        // Bullets hitting Enemies/Player
        bullets.forEach(b => {
            if (b.dead) return;

            if (b.isEnemy) {
                // Check Player hit
                const dist = Vec2.dist(b.pos, player.pos);
                if (dist < player.radius + 5) {
                    player.health -= b.damage;
                    b.dead = true;
                    this.sound.hit();
                    this.spawnParticles(player.pos.x, player.pos.y, '#ff0000', 5);
                    if (player.health <= 0) player.dead = true;
                }
            } else {
                // Check Enemy hit
                enemies.forEach(e => {
                    if (e.dead) return;
                    const dist = Vec2.dist(b.pos, e.pos);
                    if (dist < e.radius + 5) {
                        e.hp -= b.damage;
                        b.dead = true;
                        this.sound.hit();
                        this.spawnParticles(e.pos.x, e.pos.y, e.color, 3);
                        if (e.hp <= 0) {
                            e.dead = true;
                            this.score += e.scoreValue;
                            this.sound.explosion();
                            this.spawnParticles(e.pos.x, e.pos.y, e.color, 15);
                        }
                    }
                });
            }
        });

        // Player hitting Enemy (Crash)
        enemies.forEach(e => {
            if (e.dead) return;
            const dist = Vec2.dist(e.pos, player.pos);
            if (dist < e.radius + player.radius) {
                player.health -= 10;
                e.dead = true;
                this.sound.explosion();
                this.spawnParticles(e.pos.x, e.pos.y, '#ff9900', 10);
                if (player.health <= 0) player.dead = true;
            }
        });
    }

    draw() {
        // Clear Background
        this.ctx.fillStyle = '#050510';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw Stars
        this.ctx.fillStyle = '#ffffff';
        this.stars.forEach(s => {
            this.ctx.globalAlpha = Math.random() * 0.5 + 0.3;
            this.ctx.fillRect(s.x, s.y, s.size, s.size);
            s.y += s.speed;
            if (s.y > this.canvas.height) s.y = 0;
        });
        this.ctx.globalAlpha = 1;

        if (this.state === 'PLAYING' || this.state === 'SHOP') {
            const { player, bullets, enemies, particles } = this.entities;
            
            // Draw Entities
            particles.forEach(p => p.draw(this.ctx));
            bullets.forEach(b => b.draw(this.ctx));
            enemies.forEach(e => e.draw(this.ctx));
            if (player && !player.dead) player.draw(this.ctx);
        }
    }

    openShop() {
        this.state = 'SHOP';
        document.getElementById('shop-screen').classList.add('active');
        this.updateShopButtons();
    }

    nextWave() {
        document.getElementById('shop-screen').classList.remove('active');
        this.wave++;
        this.startWave();
        this.state = 'PLAYING';
    }

    updateShopButtons() {
        // Simple logic to dim buttons if too expensive
        const costs = {
            fireRate: 1000 * this.entities.player.stats.fireRateLvl,
            damage: 1500 * this.entities.player.stats.damageLvl,
            speed: 800 * this.entities.player.stats.speedLvl,
            health: 500
        };

        // Update Text
        document.getElementById('cost-fireRate').innerText = costs.fireRate + " CR";
        document.getElementById('cost-damage').innerText = costs.damage + " CR";
        document.getElementById('cost-speed').innerText = costs.speed + " CR";
        document.getElementById('cost-health').innerText = costs.health + " CR";
    }

    upgrade(type) {
        const p = this.entities.player;
        let cost = 0;

        if (type === 'fireRate') {
            cost = 1000 * p.stats.fireRateLvl;
            if (this.score >= cost) {
                this.score -= cost;
                p.stats.fireRateLvl++;
                p.fireRate *= 0.85; // Faster fire
                this.sound.upgrade();
            }
        } else if (type === 'damage') {
            cost = 1500 * p.stats.damageLvl;
            if (this.score >= cost) {
                this.score -= cost;
                p.stats.damageLvl++;
                p.damage += 15;
                this.sound.upgrade();
            }
        } else if (type === 'speed') {
            cost = 800 * p.stats.speedLvl;
            if (this.score >= cost) {
                this.score -= cost;
                p.stats.speedLvl++;
                p.speed += 50;
                this.sound.upgrade();
            }
        } else if (type === 'health') {
            cost = 500;
            if (this.score >= cost && p.health < 100) {
                this.score -= cost;
                p.health = Math.min(100, p.health + 50);
                this.sound.upgrade();
            }
        }
        
        this.updateShopButtons();
        document.getElementById('shop-credits').innerText = this.score;
        document.getElementById('score-display').innerText = this.score;
        document.getElementById('health-fill').style.width = `${Math.max(0, p.health)}%`;
    }

    gameOver() {
        this.state = 'GAMEOVER';
        if (this.score > this.highScore) {
            this.highScore = this.score;
            localStorage.setItem('neon_high', this.highScore);
        }
        document.getElementById('final-score').innerText = this.score;
        document.getElementById('game-over-screen').classList.add('active');
    }

    reset() {
        document.getElementById('game-over-screen').classList.remove('active');
        this.start();
    }
}

// Init Game on Load
window.onload = () => {
    window.game = new Game();
};

</script>
</body>
</html>
