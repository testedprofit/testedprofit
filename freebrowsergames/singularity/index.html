<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SINGULARITY</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #080808;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none;
            cursor: none; /* Hide default cursor */
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            color: rgba(255, 255, 255, 0.8);
            z-index: 10;
        }
        h1 {
            font-size: 1.5rem;
            margin: 0;
            letter-spacing: 4px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        .stat {
            font-size: 0.9rem;
            margin-top: 5px;
            color: #888;
        }
        #score-val { color: #fff; font-weight: bold; }
        
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 20;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        #game-over.visible {
            opacity: 1;
            pointer-events: all;
        }
        button {
            background: transparent;
            color: white;
            border: 1px solid white;
            padding: 15px 30px;
            font-size: 1rem;
            font-family: inherit;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.2s;
        }
        button:hover {
            background: white;
            color: black;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }
        .tutorial {
            position: absolute;
            bottom: 10%;
            width: 100%;
            text-align: center;
            color: #666;
            font-size: 0.8rem;
            pointer-events: none;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <h1>SINGULARITY</h1>
    <div class="stat">SCORE: <span id="score-val">0</span></div>
    <div class="stat">CORE INTEGRITY: <span id="health-val">100%</span></div>
</div>

<div id="game-over">
    <h1 style="font-size: 3rem; margin-bottom: 10px;">CRITICAL FAILURE</h1>
    <p>The Core was breached.</p>
    <p>Final Score: <span id="final-score">0</span></p>
    <button onclick="resetGame()">REBOOT SIMULATION</button>
</div>

<div class="tutorial" id="tutorial-msg">CLICK & HOLD to generate Gravity.<br>Make enemies crash into each other.</div>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * SINGULARITY
 * A physics-based defense game.
 * * Core Mechanics:
 * - Enemies spawn at edges and target the center (Core).
 * - Player controls a gravity well (mouse/touch).
 * - Gravity pulls enemies, curving their trajectory.
 * - Enemy collision = Destruction + Score.
 * - Core collision = Damage.
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiScore = document.getElementById('score-val');
const uiHealth = document.getElementById('health-val');
const uiGameOver = document.getElementById('game-over');
const uiFinalScore = document.getElementById('final-score');
const uiTutorial = document.getElementById('tutorial-msg');

let width, height, centerX, centerY;
let isRunning = true;
let score = 0;
let coreHealth = 100;
let frameCount = 0;
let difficulty = 1;

// Input
const mouse = { x: 0, y: 0, down: false };

// Game Entities
const enemies = [];
const particles = [];
const shockwaves = [];
const floatingText = [];

// Constants
const GRAVITY_STRENGTH = 0.8; 
const ENEMY_BASE_SPEED = 2.0;
const CORE_RADIUS = 30;

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    centerX = width / 2;
    centerY = height / 2;
}
window.addEventListener('resize', resize);
resize();

// Input Listeners
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
window.addEventListener('mousedown', () => { mouse.down = true; uiTutorial.style.opacity = 0; });
window.addEventListener('mouseup', () => mouse.down = false);

window.addEventListener('touchmove', e => {
    e.preventDefault();
    mouse.x = e.touches[0].clientX;
    mouse.y = e.touches[0].clientY;
}, {passive: false});
window.addEventListener('touchstart', e => {
    mouse.down = true;
    mouse.x = e.touches[0].clientX;
    mouse.y = e.touches[0].clientY;
    uiTutorial.style.opacity = 0;
});
window.addEventListener('touchend', () => mouse.down = false);

class Enemy {
    constructor() {
        // Spawn on edge
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.max(width, height) * 0.6; // Outside screen
        this.x = centerX + Math.cos(angle) * dist;
        this.y = centerY + Math.sin(angle) * dist;
        
        this.radius = 6 + Math.random() * 4;
        this.mass = this.radius; // Bigger = harder to pull
        
        // Initial velocity towards center
        const angleToCenter = Math.atan2(centerY - this.y, centerX - this.x);
        const speed = ENEMY_BASE_SPEED + (Math.random() * difficulty * 0.5);
        
        this.vx = Math.cos(angleToCenter) * speed;
        this.vy = Math.sin(angleToCenter) * speed;
        
        this.color = `hsl(${Math.random() * 40 + 340}, 80%, 60%)`; // Reds/Pinks
        this.trail = [];
        this.dead = false;
    }

    update() {
        // 1. Gravity Influence (from Player)
        if (mouse.down) {
            const dx = mouse.x - this.x;
            const dy = mouse.y - this.y;
            const distSq = dx*dx + dy*dy;
            const dist = Math.sqrt(distSq);
            
            // F = G * (m1*m2) / r^2
            // Clamped distance to prevent catapulting too hard
            const force = (GRAVITY_STRENGTH * 1000) / Math.max(1000, distSq); 
            
            const angle = Math.atan2(dy, dx);
            this.vx += Math.cos(angle) * force;
            this.vy += Math.sin(angle) * force;
        }

        // 2. Core Pull (Slight constant gravity towards core to prevent drifting forever)
        const dxCore = centerX - this.x;
        const dyCore = centerY - this.y;
        const angleCore = Math.atan2(dyCore, dxCore);
        this.vx += Math.cos(angleCore) * 0.02;
        this.vy += Math.sin(angleCore) * 0.02;

        // 3. Apply Velocity
        this.x += this.vx;
        this.y += this.vy;

        // 4. Trail
        if (frameCount % 3 === 0) {
            this.trail.push({x: this.x, y: this.y, age: 1.0});
            if (this.trail.length > 10) this.trail.shift();
        }

        // 5. Bounds cleanup (if flung way off screen)
        if (this.x < -width || this.x > width*2 || this.y < -height || this.y > height*2) {
            this.dead = true; // Lost to the void
        }
    }

    draw(ctx) {
        // Draw Trail
        ctx.beginPath();
        for (let i = 0; i < this.trail.length - 1; i++) {
            const t = this.trail[i];
            const next = this.trail[i+1];
            ctx.lineWidth = t.age * (this.radius / 2);
            ctx.strokeStyle = this.color;
            ctx.globalAlpha = t.age * 0.5;
            ctx.moveTo(t.x, t.y);
            ctx.lineTo(next.x, next.y);
            ctx.stroke();
            t.age -= 0.05;
        }
        ctx.globalAlpha = 1;

        // Draw Head
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Glow
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius + 2, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

class Particle {
    constructor(x, y, color, speed) {
        this.x = x;
        this.y = y;
        const angle = Math.random() * Math.PI * 2;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 1.0;
        this.decay = 0.02 + Math.random() * 0.03;
        this.color = color;
        this.size = Math.random() * 3;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.95; // Friction
        this.vy *= 0.95;
        this.life -= this.decay;
    }
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

class Shockwave {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 1;
        this.alpha = 1;
    }
    update() {
        this.radius += 5;
        this.alpha -= 0.05;
    }
    draw(ctx) {
        if(this.alpha <= 0) return;
        ctx.strokeStyle = `rgba(255, 255, 255, ${this.alpha})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.stroke();
    }
}

function spawnExplosion(x, y, color, sizeMod) {
    for (let i = 0; i < 8 * sizeMod; i++) {
        particles.push(new Particle(x, y, color, (Math.random() * 5 + 2) * sizeMod));
    }
    shockwaves.push(new Shockwave(x, y));
}

function checkCollisions() {
    // Enemy vs Enemy
    for (let i = 0; i < enemies.length; i++) {
        let e1 = enemies[i];
        if (e1.dead) continue;

        // Check against Core
        const distToCore = Math.hypot(e1.x - centerX, e1.y - centerY);
        if (distToCore < CORE_RADIUS + e1.radius) {
            e1.dead = true;
            coreHealth -= 10; // Damage
            spawnExplosion(e1.x, e1.y, '#f00', 1);
            screenShake = 10;
            if (coreHealth <= 0) gameOver();
            continue;
        }

        // Check against other enemies
        for (let j = i + 1; j < enemies.length; j++) {
            let e2 = enemies[j];
            if (e2.dead) continue;

            const dx = e1.x - e2.x;
            const dy = e1.y - e2.y;
            const dist = Math.hypot(dx, dy);

            if (dist < e1.radius + e2.radius) {
                // COLLISION!
                e1.dead = true;
                e2.dead = true;
                
                // Score Calculation
                // Faster collision = more points
                const impactForce = Math.hypot(e1.vx - e2.vx, e1.vy - e2.vy);
                const points = Math.floor(100 * (impactForce * 0.5));
                score += points;
                
                spawnExplosion((e1.x+e2.x)/2, (e1.y+e2.y)/2, '#fff', 1.5);
                screenShake = 5;
                
                // Add floating text
                floatingText.push({
                    x: (e1.x+e2.x)/2, y: (e1.y+e2.y)/2, 
                    text: points, life: 1.0, dy: -1
                });
            }
        }
    }
}

let screenShake = 0;

function loop() {
    if (!isRunning) return;
    
    // Logic
    frameCount++;
    
    // Spawning
    if (frameCount % Math.max(20, 100 - (difficulty * 5)) === 0) {
        enemies.push(new Enemy());
        // Slowly increase difficulty
        if (frameCount % 500 === 0) difficulty++;
    }

    // Update Entities
    enemies.forEach(e => e.update());
    checkCollisions();
    particles.forEach(p => p.update());
    shockwaves.forEach(s => s.update());
    
    // Clean up
    for(let i = enemies.length-1; i>=0; i--) if(enemies[i].dead) enemies.splice(i, 1);
    for(let i = particles.length-1; i>=0; i--) if(particles[i].life <= 0) particles.splice(i, 1);
    for(let i = shockwaves.length-1; i>=0; i--) if(shockwaves[i].alpha <= 0) shockwaves.splice(i, 1);

    // Screen Shake Decay
    let sx = 0, sy = 0;
    if (screenShake > 0) {
        sx = (Math.random() - 0.5) * screenShake;
        sy = (Math.random() - 0.5) * screenShake;
        screenShake *= 0.9;
        if(screenShake < 0.5) screenShake = 0;
    }

    // Draw
    ctx.fillStyle = '#080808';
    ctx.fillRect(0, 0, width, height);

    ctx.save();
    ctx.translate(sx, sy);

    // Draw Gravity Well (Cursor)
    if (mouse.down) {
        ctx.beginPath();
        const grad = ctx.createRadialGradient(mouse.x, mouse.y, 5, mouse.x, mouse.y, 100);
        grad.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
        grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = grad;
        ctx.arc(mouse.x, mouse.y, 150, 0, Math.PI * 2);
        ctx.fill();
        
        // Sucking lines effect
        ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
        ctx.lineWidth = 1;
        for(let i=0; i<5; i++) {
            const angle = Math.random() * Math.PI * 2;
            const r = 20 + Math.random() * 80;
            ctx.beginPath();
            ctx.moveTo(mouse.x + Math.cos(angle)*r, mouse.y + Math.sin(angle)*r);
            ctx.lineTo(mouse.x, mouse.y);
            ctx.stroke();
        }
    }

    // Draw Core
    ctx.shadowBlur = 20;
    ctx.shadowColor = '#0ff';
    ctx.fillStyle = '#0ff';
    ctx.beginPath();
    ctx.arc(centerX, centerY, CORE_RADIUS, 0, Math.PI * 2);
    ctx.fill();
    
    // Core Health Indicator (Circle outline)
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 3;
    ctx.stroke();
    
    // Health Arc
    if (coreHealth > 0) {
        ctx.beginPath();
        ctx.strokeStyle = coreHealth > 50 ? '#0f0' : '#f00';
        ctx.arc(centerX, centerY, CORE_RADIUS + 5, 0, (Math.PI * 2) * (coreHealth/100));
        ctx.stroke();
    }
    ctx.shadowBlur = 0;

    // Draw Entities
    shockwaves.forEach(s => s.draw(ctx));
    particles.forEach(p => p.draw(ctx));
    enemies.forEach(e => e.draw(ctx));

    // Draw Floating Text
    for(let i=floatingText.length-1; i>=0; i--) {
        let ft = floatingText[i];
        ft.y += ft.dy;
        ft.life -= 0.02;
        
        ctx.globalAlpha = Math.max(0, ft.life);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px Courier New';
        ctx.fillText("+" + ft.text, ft.x, ft.y);
        ctx.globalAlpha = 1;
        
        if(ft.life <= 0) floatingText.splice(i, 1);
    }

    // Draw Cursor
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(mouse.x, mouse.y, 10, 0, Math.PI*2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(mouse.x, mouse.y, 2, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();

    // UI Updates
    uiScore.innerText = score;
    uiHealth.innerText = Math.max(0, coreHealth) + "%";

    requestAnimationFrame(loop);
}

function gameOver() {
    isRunning = false;
    uiGameOver.classList.add('visible');
    uiFinalScore.innerText = score;
}

function resetGame() {
    score = 0;
    coreHealth = 100;
    difficulty = 1;
    frameCount = 0;
    enemies.length = 0;
    particles.length = 0;
    shockwaves.length = 0;
    isRunning = true;
    uiGameOver.classList.remove('visible');
    loop();
}

loop();

</script>
</body>
</html>
